<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <meta name="description" content="2020/6/16，go团队发布了新的go泛型草案，用类型参数type parameters来限制或者说声明
原文：https://go.googlesource.com/proposal/+/refs/heads/master/design/go2draft-type-parameters.md历史草案：https://go.googlesource.com/proposal/+/refs/heads/master/design/go2draft-contracts.mdplayground：https://go2goplay.golang.org/Go泛型讨论概要：https://docs.google.com/document/d/1vrAy9gMpMoS3uaVphB32uVXX4pi-HnNjkMEgyAHX4N4/view#" />
  

  
  
  
  
  
  
  <title>go2_type_parameters | williamG</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="2020&#x2F;6&#x2F;16，go团队发布了新的go泛型草案，用类型参数type parameters来限制或者说声明 原文：https:&#x2F;&#x2F;go.googlesource.com&#x2F;proposal&#x2F;+&#x2F;refs&#x2F;heads&#x2F;master&#x2F;design&#x2F;go2draft-type-parameters.md历史草案：https:&#x2F;&#x2F;go.googlesource.com&#x2F;proposal&#x2F;+&#x2F;refs&#x2F;he">
<meta property="og:type" content="article">
<meta property="og:title" content="go2_type_parameters">
<meta property="og:url" content="http://yoursite.com/2020/07/13/go2-type-parameters/index.html">
<meta property="og:site_name" content="williamG">
<meta property="og:description" content="2020&#x2F;6&#x2F;16，go团队发布了新的go泛型草案，用类型参数type parameters来限制或者说声明 原文：https:&#x2F;&#x2F;go.googlesource.com&#x2F;proposal&#x2F;+&#x2F;refs&#x2F;heads&#x2F;master&#x2F;design&#x2F;go2draft-type-parameters.md历史草案：https:&#x2F;&#x2F;go.googlesource.com&#x2F;proposal&#x2F;+&#x2F;refs&#x2F;he">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-07-13T10:40:43.000Z">
<meta property="article:modified_time" content="2020-07-21T18:58:04.092Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="golang">
<meta property="article:tag" content="generics">
<meta name="twitter:card" content="summary">
  
  
    <link rel="icon" href="/css/images/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  

  
  <!-- baidu webmaster push -->
  <script src='//zz.bdstatic.com/linksubmit/push.js'></script>
<meta name="generator" content="Hexo 4.2.0"></head>
<body class="home blog custom-background custom-font-enabled single-author">
  <div id="page" class="hfeed site">
      <header id="masthead" class="site-header" role="banner">
    <hgroup>
      <h1 class="site-title">
        <a href="/" title="williamG" rel="home">williamG</a>
      </h1>
      
        <h2 class="site-description hitokoto"></h2>
        <script type="text/javascript" src="https://v1.hitokoto.cn/?encode=js"></script>
      
    </hgroup>

    <nav id="site-navigation" class="main-navigation" role="navigation">
            <button class="menu-toggle">菜单</button>
            <a class="assistive-text" href="/#content" title="跳至内容">跳至内容</a><!--TODO-->
            <div class="menu-main-container">
                <ul id="menu-main" class="nav-menu">
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/">Home</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/archives">Archives</a></li>
                
                </ul>
            </div>
    </nav>
</header>

      <div id="main" class="wrapper">
        <div id="primary" class="site-content"><div id="content" role="main"><article id="post-go2-type-parameters" class="post-go2-type-parameters post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title article-title">
      go2_type_parameters
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2020/07/13/go2-type-parameters/" data-id="ckcwawta4000rn0l0b2wa4k1w" class="leave-reply bdsharebuttonbox" data-cmd="more"></a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>2020/6/16，go团队发布了新的go泛型草案，用类型参数type parameters来限制或者说声明</p>
<p>原文：<a href="https://go.googlesource.com/proposal/+/refs/heads/master/design/go2draft-type-parameters.md" target="_blank" rel="noopener">https://go.googlesource.com/proposal/+/refs/heads/master/design/go2draft-type-parameters.md</a><br>历史草案：<a href="https://go.googlesource.com/proposal/+/refs/heads/master/design/go2draft-contracts.md" target="_blank" rel="noopener">https://go.googlesource.com/proposal/+/refs/heads/master/design/go2draft-contracts.md</a><br>playground：<a href="https://go2goplay.golang.org/" target="_blank" rel="noopener">https://go2goplay.golang.org/</a><br>Go泛型讨论概要：<a href="https://docs.google.com/document/d/1vrAy9gMpMoS3uaVphB32uVXX4pi-HnNjkMEgyAHX4N4/view#" target="_blank" rel="noopener">https://docs.google.com/document/d/1vrAy9gMpMoS3uaVphB32uVXX4pi-HnNjkMEgyAHX4N4/view#</a></p>
<a id="more"></a>

<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>我们提议用对类型和函数添加可选的类型参数的方式来扩展go语言。类型参数可以被接口类型所限<br>制。同时我们也提议用类型常量来列出它们可能被允许分配的类型集合来扩展接口类型。在很多情<br>况下通过一个统一的算法进行类型推断以支持在函数调用中允许省略类型参数。</p>
<h1 id="如何阅读这篇设计草案"><a href="#如何阅读这篇设计草案" class="headerlink" title="如何阅读这篇设计草案"></a>如何阅读这篇设计草案</h1><p>由于文章篇幅较长，故列出一些引导要点来帮助你阅读。</p>
<ul>
<li>首先会从高层次上简短地描述一下概念。</li>
<li>然后我们会从零开始解释整个设计，用一些例子来介绍细节</li>
<li>描述完全部设计之后，我们将会讨论实现细节，一些设计上的问题以及与其它实现泛型的方法的比较。</li>
<li>然后我们将会呈现一些该设计下的如何应用泛型到实际中的几个例子。</li>
<li>紧接着这些例子的附录中会讨论一些小细节。</li>
</ul>
<h1 id="高层次下的概述"><a href="#高层次下的概述" class="headerlink" title="高层次下的概述"></a>高层次下的概述</h1><p>这个章节简短地解释了设计草案所提议的变更。目标受众是已经熟悉泛型应该如何在编程语言下<br>比如Go工作的读者。这些概念将会在后面的章节详细阐述。</p>
<ul>
<li>函数可以通过关键词<code>type</code>来声明额外的类型参数列表：<code>func F(type T)(p T) {...}</code></li>
<li>这些类型参数可以在函数体中用作为正常的参数</li>
<li>类型也可以(在声明时)拥有类型参数列表：<code>type M(type T) []T</code></li>
<li>每个类型参数可以拥有额外的类型约束：<code>func F(type T Constraint) (p T) {...}</code></li>
<li>类型约束也就是接口类型</li>
<li>用作为类型约束的接口类型可以拥有一个预先声明类型的列表，只有那些潜在类型是上述列表之一的类型可以实现这些接口</li>
<li>调用泛型函数或者泛型类型需要传递类型参数</li>
<li>类型推断通常情况下允许省略类型参数</li>
<li>如果类型参数拥有类型约束那么它的类型参数必须实现了该接口</li>
<li>泛型函数只可以类型参数约束下的操作</li>
</ul>
<p>接下来的章节我们会事无巨细地遍览这些语言层面的变更。你可能更想跳到#例子那里来看实际中泛型代码如何书写。</p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>这个版本的设计草案与2019/7/31版的有很多相似点，但contract已经被移除并用接口类型代替。</p>
<p>之前有很多在Go中加入泛型编程的支持的<a href="https://github.com/golang/go/wiki/ExperienceReports#generics" target="_blank" rel="noopener">请求</a>。这个已经在<a href="https://golang.org/issue/15292" target="_blank" rel="noopener">issue</a>和<a href="https://docs.google.com/document/d/1vrAy9gMpMoS3uaVphB32uVXX4pi-HnNjkMEgyAHX4N4/view" target="_blank" rel="noopener">在线文档</a>中有所讨论。</p>
<p>在上述链接中可以发现已经有一些对加入类型参数的提议。本文呈现的很多想法都在之前提到过。<br>主要的新特性还是在语法和对接口类型作为约束的仔细检查。</p>
<p>本设计草案提议加入一种参数多态的形式来扩展Go语言，此时类型参数并非以一种声明式子类型<br>关系(一些面向对象语言)，而是通过显式定义的结构化约束来绑定。</p>
<p>本文的设计不支持模板元编程或者任何其它形式的编译期编程(泛型?)。</p>
<p>鉴于<em>generic</em>已经在Go社区中广泛使用，我们接下来会使用它作为代指采用类型参数的函数或<br>类型的简称。请勿混淆本文中的术语generic与其它语言比如C++,C#,Java或者Rust中的generic，<br>它们有共同点但并非完全相同。</p>
<h1 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h1><p>我们将会基于一些简单的例子来逐步阐述完整的设计理念。</p>
<h1 id="类型参数"><a href="#类型参数" class="headerlink" title="类型参数"></a>类型参数</h1><p>泛型代码指的是那些使用了后面才会指定的类型的代码。未指定的类型称之为<em>类型参数<br>type parameter</em>。当执行泛型代码时，类型参数将会被设置为具体的<em>类型实参type argument</em>。</p>
<p>下面是一个打印切片中所有元素的函数，切片的元素类型即T是不确定的。这只是我们为了支持泛型<br>编程而举的小例子，之后我们会讨论泛型类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Print prints the elements of a slice.</span></span><br><span class="line"><span class="comment">// It should be possible to call this with any slice value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print</span><span class="params">(s []T)</span></span> &#123; <span class="comment">// Just an example, not the suggested syntax.</span></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">		fmt.Println(v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以这种方法的话，需要作出的第一个决定就是：类型参数<strong>T</strong>应当如何声明?在Go中，我们希望每个<br>标识符都以某种方式声明。</p>
<p>在这里我们作出了一个设计决策：类型参数应当类似于通常的无类型函数参数，并且这些应当与其他<br>参数列在一起。然而类型参数与无类型参数并非一样，因此即使它们位于参数列表中我们还是得区别<br>它们。这就引出了我们作出的下一个决策：我们定义了一个额外的可选的参数列表，用以描述类型参<br>数。这个参数列表位于正常的参数之前，它以关键词<code>type</code>起头列出了类型参数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Print prints the elements of any slice.</span></span><br><span class="line"><span class="comment">// Print has a type parameter T, and has a single (non-type)</span></span><br><span class="line"><span class="comment">// parameter s which is a slice of that type parameter.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print</span><span class="params">(<span class="keyword">type</span> T)</span><span class="params">(s []T)</span></span> &#123;</span><br><span class="line">	<span class="comment">// same as above</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的含义是在函数<code>Print</code>里标识符<code>T</code>是一个类型参数，T目前未知但当函数调用时将会是确定的。<br>如上所示，类型参数可以用来作为一个类型来描述通常的无类型参数。它也可能会在函数体内使用。</p>
<p>既然<code>Print</code>有了一个类型参数，任何对<code>Print</code>的调用必须提供类型实参。之后我们将会看到这个<br>类型实参如何通过<em>function argument type inference</em>从无类型参数中推导出来。<br>目前我们是显式传递类型实参。类型实参传递形式与类型参数声明形式非常相似：一串单独的参数<br>列表。在调用时不需要用<code>type</code>关键字。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Call Print with a []int.</span></span><br><span class="line"><span class="comment">// Print has a type parameter T, and we want to pass a []int,</span></span><br><span class="line"><span class="comment">// so we pass a type argument of int by writing Print(int).</span></span><br><span class="line"><span class="comment">// The function Print(int) expects a []int as an argument.</span></span><br><span class="line"></span><br><span class="line">Print(<span class="keyword">int</span>)([]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// This will print:</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>


<h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><p>让我们稍微举个复杂点的例子。把它变成一个函数，通过对每个元素调用<code>String</code>方法将任意类型的切片转化为<code>[]string</code>切片。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This function is INVALID.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Stringify</span><span class="params">(<span class="keyword">type</span> T)</span><span class="params">(s []T)</span> <span class="params">(ret []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">		ret = <span class="built_in">append</span>(ret, v.String()) <span class="comment">// INVALID</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>乍一看似乎看起来OK，但这个例子里v属于类型T，但我们对于T一无所知。特别地，我们并不能确定<br>T是否有String方法，因此调用<code>v.String()</code>是非法的。</p>
<p>理所当然地，这样的问题在其它支持泛型编程的语言里也会出现。在C++中，一个泛型函数(用C++术<br>语叫函数模板)可以对泛型类型的值调用任意方法。也就是说，以C++的方式来说，调用<code>v.String()</code><br>是合法的。如果调用函数时传入的类型实参没有String方法，编译类型实参调用v.String时报错。<br>由于可能在错误发生前会好几层泛型函数调用，并且为了明确哪里出错，这些错误必须全部报出，<br>因此报错信息可能会很冗长，</p>
<p>C++的方式对于Go来说是个糟糕的选择。其中一个原因就是在于语言风格上。在Go里我们不会参照<br>名称?，在这种情况下就是<code>String</code>,而是期望它们存在。Go在看到它们的时候会将所有的名字解析<br>为其声明。</p>
<p>另一个原因在于Go本身是一个为大规模编程设计的语言。我们必须考虑在泛型函数定义(上述的<br>Stringify)与对泛型函数的调用(未标明，可能在其它包)相隔甚远的情况。总的来说，所有泛型代码<br>期望类型实参能够满足某个要求，我们把这些要求称之为<em>约束constraints</em>(其它语言里可能有类似<br>概念比如type bounds或者trait bounds或者concepts)。在这种情况下，约束就相当明显了：类型<br>必须有String()方法。其它情况的话可能会没那么明显。</p>
<p>我们并不想从Stringify碰巧所做所为(这个例子中即String方法)来推导约束。如果这样做的话，对<br>Stringify稍微改动一点都会改变约束。这将意味着一个小小的改动可能导致相隔甚远的调用它的代码<br>出现意外故障。谨慎地改变Stringify的约束并且强迫调用者来改变是个不错的做法。我们所想避免的<br>就是Stringify意外改变了它的约束。</p>
<p>这意味着约束必须限制传递的类型实参和泛型函数的代码两者。调用者必须只传递满足约束的类型实<br>参。泛型函数只能以约束许可的方式使用这些值。这也是一条很重要的规则，我们相信它应该适用于<br>任何定义Go泛型编程的尝试中：<br>  <em>generic code can only use operations that its type arguments are known to implement</em>。</p>
<h1 id="定义约束"><a href="#定义约束" class="headerlink" title="定义约束"></a>定义约束</h1><p>defining constraints。<br>Go已经有一个与之非常相近的概念：interface。当然除了方法调用之外，还可以定义对操作的约束。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stringer is a type constraint that requires the type argument to have</span></span><br><span class="line"><span class="comment">// a String method and permits the generic function to call String.</span></span><br><span class="line"><span class="comment">// The String method should return a string representation of the value.</span></span><br><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">	String() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="使用约束"><a href="#使用约束" class="headerlink" title="使用约束"></a>使用约束</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stringify calls the String method on each element of s,</span></span><br><span class="line"><span class="comment">// and returns the results.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Stringify</span><span class="params">(<span class="keyword">type</span> T Stringer)</span><span class="params">(s []T)</span> <span class="params">(ret []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">		ret = <span class="built_in">append</span>(ret, v.String())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="多类型参数"><a href="#多类型参数" class="headerlink" title="多类型参数"></a>多类型参数</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Print2 has two type parameters and two non-type parameters.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print2</span><span class="params">(<span class="keyword">type</span> T1, T2)</span><span class="params">(s1 []T1, s2 []T2)</span></span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Print2Same has one type parameter and two non-type parameters.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print2Same</span><span class="params">(<span class="keyword">type</span> T)</span><span class="params">(s1 []T, s2 []T)</span></span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>Print2中s1和s2的元素类型可能相同或不同，而Print2Same中两者的元素类型必须相同。</p>
<p>每个类型参数可能有自己的约束：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stringer is a type constraint that requires a String method.</span></span><br><span class="line"><span class="comment">// The String method should return a string representation of the value.</span></span><br><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">	String() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Plusser is a type constraint that requires a Plus method.</span></span><br><span class="line"><span class="comment">// The Plus method is expected to add the argument to an internal</span></span><br><span class="line"><span class="comment">// string and return the result.</span></span><br><span class="line"><span class="keyword">type</span> Plusser <span class="keyword">interface</span> &#123;</span><br><span class="line">	Plus(<span class="keyword">string</span>) <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConcatTo takes a slice of elements with a String method and a slice</span></span><br><span class="line"><span class="comment">// of elements with a Plus method. The slices should have the same</span></span><br><span class="line"><span class="comment">// number of elements. This will convert each element of s to a string,</span></span><br><span class="line"><span class="comment">// pass it to the Plus method of the corresponding element of p,</span></span><br><span class="line"><span class="comment">// and return a slice of the resulting strings.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ConcatTo</span><span class="params">(<span class="keyword">type</span> S Stringer, P Plusser)</span><span class="params">(s []S, p []P)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">	r := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="built_in">len</span>(s))</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">		r[i] = p[i].Plus(v.String())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果某个类型参数指定了约束，则所有的类型参数都必须有约束。如果其它的不需要约束，可以<br>用<code>interface{}</code>来代表无约束。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StrAndPrint takes a slice of labels, which can be any type,</span></span><br><span class="line"><span class="comment">// and a slice of values, which must have a String method,</span></span><br><span class="line"><span class="comment">// converts the values to strings, and prints the labelled strings.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StrAndPrint</span><span class="params">(<span class="keyword">type</span> L <span class="keyword">interface</span>&#123;&#125;, T Stringer)</span><span class="params">(labels []L, vals []T)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Stringify was defined above. It returns a []string.</span></span><br><span class="line">	<span class="keyword">for</span> i, s := <span class="keyword">range</span> Stringify(vals) &#123;</span><br><span class="line">		fmt.Println(labels[i], s)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个约束可以作用于多个类型参数，就像函数里参数的声明那样。约束会分别作用于每个类型参数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stringify2 converts two slices of different types to strings,</span></span><br><span class="line"><span class="comment">// and returns the concatenation of all the strings.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Stringify2</span><span class="params">(<span class="keyword">type</span> T1, T2 Stringer)</span><span class="params">(s1 []T1, s2 []T2)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	r := <span class="string">""</span></span><br><span class="line">	<span class="keyword">for</span> _, v1 := <span class="keyword">range</span> s1 &#123;</span><br><span class="line">		r += v1.String()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, v2 := <span class="keyword">range</span> s2 &#123;</span><br><span class="line">		r += v2.String()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="泛型类型"><a href="#泛型类型" class="headerlink" title="泛型类型"></a>泛型类型</h1><p>除了泛型函数之外，我们可能还需要支持类型参数的泛型类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vector is a name for a slice of any element type.</span></span><br><span class="line"><span class="keyword">type</span> Vector(<span class="keyword">type</span> T) []T</span><br><span class="line"></span><br><span class="line"><span class="comment">// v is a Vector of int values.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This is similar to pretending that "Vector(int)" is a valid identifier,</span></span><br><span class="line"><span class="comment">// and writing</span></span><br><span class="line"><span class="comment">//   type "Vector(int)" []int</span></span><br><span class="line"><span class="comment">//   var v "Vector(int)"</span></span><br><span class="line"><span class="comment">// All uses of Vector(int) will refer to the same "Vector(int)" type.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">var</span> v Vector(<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>

<p>泛型类型可以有自己的方法，方法的接收者类型与其类型定义的类型参数个数必须一致。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Push adds a value to the end of a vector.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vector(T)</span>) <span class="title">Push</span><span class="params">(x T)</span></span> &#123; *v = <span class="built_in">append</span>(*v, x) &#125;</span><br></pre></td></tr></table></figure>

<p>方法声明中类型参数的名称并非一定要与定义时一致。特别地，如果方法中并没有使用这个类型，<br>可以写成<code>_</code>。</p>
<p>泛型类型可以指向自己，但此时如果有多个类型参数时顺序必须保持一致。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// List is a linked list of values of type T.</span></span><br><span class="line"><span class="keyword">type</span> List(<span class="keyword">type</span> T) <span class="keyword">struct</span> &#123;</span><br><span class="line">	next *List(T) <span class="comment">// this reference to List(T) is OK</span></span><br><span class="line">	val  T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This type is INVALID.</span></span><br><span class="line"><span class="keyword">type</span> P(<span class="keyword">type</span> T1, T2) <span class="keyword">struct</span> &#123;</span><br><span class="line">	F *P(T2, T1) <span class="comment">// INVALID; must be (T1, T2)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在间接引用时也必须符合这个原则。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ListHead is the head of a linked list.</span></span><br><span class="line"><span class="keyword">type</span> ListHead(<span class="keyword">type</span> T) <span class="keyword">struct</span> &#123;</span><br><span class="line">	head *ListElement(T)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ListElement is an element in a linked list with a head.</span></span><br><span class="line"><span class="comment">// Each element points back to the head.</span></span><br><span class="line"><span class="keyword">type</span> ListElement(<span class="keyword">type</span> T) <span class="keyword">struct</span> &#123;</span><br><span class="line">	next *ListElement(T)</span><br><span class="line">	val  T</span><br><span class="line">	<span class="comment">// Using ListHead(T) here is OK.</span></span><br><span class="line">	<span class="comment">// ListHead(T) refers to ListElement(T) refers to ListHead(T).</span></span><br><span class="line">	<span class="comment">// Using ListHead(int) would not be OK, as ListHead(T)</span></span><br><span class="line">	<span class="comment">// would have an indirect reference to ListHead(int).</span></span><br><span class="line">	head *ListHead(T)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型类型的类型参数也可以是约束。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StringableVector is a slice of some type, where the type</span></span><br><span class="line"><span class="comment">// must have a String method.</span></span><br><span class="line"><span class="keyword">type</span> StringableVector(<span class="keyword">type</span> T Stringer) []T</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s StringableVector(T)</span>) <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> sb strings.Builder</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">		<span class="keyword">if</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">			sb.WriteString(<span class="string">", "</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// It's OK to call v.String here because v is of type T</span></span><br><span class="line">		<span class="comment">// and T's constraint is Stringer.</span></span><br><span class="line">		sb.WriteString(v.String())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sb.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p><em>Operators</em></p>
<p>目前为止，我们都是把接口用作约束，而接口只是一系列方法的集合。这就意味着我们对类型参数的<br>值的唯一操作就是调用方法。</p>
<p>但仅仅能调用方法是不够的，下面这个函数是用来取切片s中的最小值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This function is INVALID.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Smallest</span><span class="params">(<span class="keyword">type</span> T)</span><span class="params">(s []T)</span> <span class="title">T</span></span> &#123;</span><br><span class="line">	r := s[<span class="number">0</span>] <span class="comment">// panic if slice is empty</span></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> s[<span class="number">1</span>:] &#123;</span><br><span class="line">		<span class="keyword">if</span> v &lt; r &#123; <span class="comment">// INVALID</span></span><br><span class="line">			r = v</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>合理的泛型实现应当能让你写得出这个函数。而问题就在于<code>v&lt;r</code>，类型T并没有保证支持<code>&lt;</code>运算<br>符。不幸的是，由于<code>&lt;</code>不是一个方法，并没有显式的方式来指定一种约束来表达满足<code>&lt;</code>运算符。</p>
<p>解决上面问题的方法就是，不为<code>&lt;</code>运算符创建一种新形式的约束，而是规定Go语言里只有有限的<br>类型能进行<code>&lt;</code>运算，也就是不准许一些组合类型进行该运算,这就引出了下面的类型约束列表。</p>
<h1 id="类型约束列表"><a href="#类型约束列表" class="headerlink" title="类型约束列表"></a>类型约束列表</h1><p><em>Type lists in constraints</em></p>
<p>类型约束列表可以显式地指定类型参数只能传入哪些类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SignedInteger is a type constraint that permits any</span></span><br><span class="line"><span class="comment">// signed integer type.</span></span><br><span class="line"><span class="keyword">type</span> SignedInteger <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="keyword">type</span> <span class="keyword">int</span>, <span class="keyword">int8</span>, <span class="keyword">int16</span>, <span class="keyword">int32</span>, <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特别地，除了其中指定的类型之外，它们的类型别名也是可传入的。<br>一个约束只能有一个类型列表。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> constraints</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ordered is a type constraint that matches any ordered type.</span></span><br><span class="line"><span class="comment">// An ordered type is one that supports the &lt;, &lt;=, &gt;, and &gt;= operators.</span></span><br><span class="line"><span class="keyword">type</span> Ordered <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="keyword">type</span> <span class="keyword">int</span>, <span class="keyword">int8</span>, <span class="keyword">int16</span>, <span class="keyword">int32</span>, <span class="keyword">int64</span>,</span><br><span class="line">		<span class="keyword">uint</span>, <span class="keyword">uint8</span>, <span class="keyword">uint16</span>, <span class="keyword">uint32</span>, <span class="keyword">uint64</span>, <span class="keyword">uintptr</span>,</span><br><span class="line">		<span class="keyword">float32</span>, <span class="keyword">float64</span>,</span><br><span class="line">		<span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上这个约束很有可能会定义在<code>constraints</code>标准库中并且可导出。</p>
<p>这样我们的Smallest函数就可以写成下面这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Smallest returns the smallest element in a slice.</span></span><br><span class="line"><span class="comment">// It panics if the slice is empty.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Smallest</span><span class="params">(<span class="keyword">type</span> T constraints.Ordered)</span><span class="params">(s []T)</span> <span class="title">T</span></span> &#123;</span><br><span class="line">	r := s[<span class="number">0</span>] <span class="comment">// panics if slice is empty</span></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> s[<span class="number">1</span>:] &#123;</span><br><span class="line">		<span class="keyword">if</span> v &lt; r &#123;</span><br><span class="line">			r = v</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="比较类型约束"><a href="#比较类型约束" class="headerlink" title="比较类型约束"></a>比较类型约束</h1><p><em>Comparable types in constraints</em></p>
<p>之前我们提到所有运算符只能适用于Go中预定义类型的情形里有两个例外，就是<code>==</code>和<code>!=</code>，<br>这两个可以用在结构体、数组以及空接口类型。由于它们非常有用因此特别为它们写了接受可比较类型的约束。</p>
<p>类型约束:<code>comparable</code>接受任何可比较类型作为实参，允许<code>==</code>和<code>!=</code>这样的运算。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Index returns the index of x in s, or -1 if not found.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Index</span><span class="params">(<span class="keyword">type</span> T comparable)</span><span class="params">(s []T, x T)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">		<span class="comment">// v and x are type T, which has the comparable</span></span><br><span class="line">		<span class="comment">// constraint, so we can use == here.</span></span><br><span class="line">		<span class="keyword">if</span> v == x &#123;</span><br><span class="line">			<span class="keyword">return</span> i</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>comparable</code>像其它约束一样，也属于接口类型。因此可以嵌入到其他接口中作为约束。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ComparableHasher is a type constraint that matches all</span></span><br><span class="line"><span class="comment">// comparable types with a Hash method.</span></span><br><span class="line"><span class="keyword">type</span> ComparableHasher <span class="keyword">interface</span> &#123;</span><br><span class="line">	comparable</span><br><span class="line">	Hash() <span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="接口类型中的类型列表"><a href="#接口类型中的类型列表" class="headerlink" title="接口类型中的类型列表"></a>接口类型中的类型列表</h1><p><em>Type lists in interface types</em></p>
<p>接口类型中的类型列表只能用在约束里，不能作为正常的接口类型使用。预定义的<code>comparable</code><br>接口同理。</p>
<h1 id="函数实参的类型推断"><a href="#函数实参的类型推断" class="headerlink" title="函数实参的类型推断"></a>函数实参的类型推断</h1><p><em>Function argument type inference</em></p>
<p>很多情况下，调用带有类型参数的函数时我们可以通过类型推断来省去显式地指定类型实参。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Print(<span class="keyword">int</span>)([]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>上面这个例子中类型实参int可以通过后面的切片类型推断出来。</p>
<p>当且仅当所有的类型参数都在入参中使用时才能推定，如果有一些类型参数只使用在函数体或函数<br>结果中，那么推断算法将无法推断出类型实参。</p>
<p>当可以推断函数的类型实参时，Go就会使用类型统一<em>type unification</em>。<br>(下面一段由于意义不甚明朗，先直译出来。)<br>类型统一是一个两步算法。第一阶段里，我们会无视那些无类型的常量以及它们在函数定义一侧对应<br>的类型，然后会逐个比较列表中对应的类型，除非函数侧的类型参数与调用侧的类型相匹配，否则它<br>们的结构必须一致，如果同样的类型参数出现多次，那么它将会匹配调用侧的多个实参。这些调用者<br>类型必须一样，否则类型统一会出错并报出来。</p>
<p>第一阶段后，我们会检查调用侧的所有无类型常量。如果没有无类型常量，或者函数的类型参数匹配<br>了其它输入类型，则类型统一就算完成。</p>
<p>否则的话，在第二阶段对于任何在函数那里没有对应类型的无类型常量我们会用往常的方法来判定无<br>类型常量。然后再执行一次类型统一算法，这次不再有无类型常量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">Print(s1)</span><br></pre></td></tr></table></figure>

<p>上面这个例子里，比较<code>[]int</code>和<code>[]T</code>，匹配T和int，然后推断完成，可以得出<code>Print(s1)</code>实际就是调用<br><code>Print(int)(s1)</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Map calls the function f on every element of the slice s,</span></span><br><span class="line"><span class="comment">// returning a new slice of the results.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Map</span><span class="params">(<span class="keyword">type</span> F, T)</span><span class="params">(s []F, f <span class="keyword">func</span>(F)</span> <span class="title">T</span>) []<span class="title">T</span></span> &#123;</span><br><span class="line">	r := <span class="built_in">make</span>([]T, <span class="built_in">len</span>(s))</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">		r[i] = f(v)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更复杂一点，上面的例子中F和T都在输入参数里用到了，因此可以进行类型推断，调用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strs := Map([]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, strconv.Itoa)</span><br></pre></td></tr></table></figure>
<p>时可以统一<code>[]int</code>与<code>[]F</code>，匹配F与int。同理匹配<code>strconv.Itoa</code>与<code>func(int) string</code>，<br>匹配F与int，T与string。类型参数F匹配了两次均为int。类型统一完成得出<code>Map</code>就是<br><code>Map(int, string)</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewPair returns a pair of values of the same type.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPair</span><span class="params">(<span class="keyword">type</span> F)</span><span class="params">(f1, f2 F)</span> *<span class="title">Pair</span><span class="params">(F)</span></span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>NewPair(1, 2)</code>时两个参数都是无类型参数因此第一阶段会被pass掉，之后把它们<br>推定为默认的int型。第二阶段里类型统一F为int型因此最终就是调用<code>NewPair(int)(1, 2)</code>。</p>
<p>而在调用<code>NewPair(1, int64(2))</code>时第一个参数无类型常量，在第一个阶段它被无视掉，<br>之后F被统一为int64，由于这时并没有任何冲突，故可以推断出<code>NewPair(int64)(1, (int64)2)</code>。</p>
<p>同理调用<code>NewPair(1, 2.5)</code>时，推断第一个参数为int，第二个float64，无法统一两者<br>因此会报出编译错误。</p>
<h1 id="约束中指向自己的类型"><a href="#约束中指向自己的类型" class="headerlink" title="约束中指向自己的类型"></a>约束中指向自己的类型</h1><p><em>Using types that refer to themselves in constraints</em></p>
<p>类型约束中可能会有指向自己的场景，典型地，比较方法中就会有这种情况。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Index returns the index of e in s, or -1 if not found.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Index</span><span class="params">(<span class="keyword">type</span> T Equaler)</span><span class="params">(s []T, e T)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">		<span class="keyword">if</span> e.Equal(v) &#123;</span><br><span class="line">			<span class="keyword">return</span> i</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Equaler is a type constraint for types with an Equal method.</span></span><br><span class="line"><span class="keyword">type</span> Equaler(<span class="keyword">type</span> T) <span class="keyword">interface</span> &#123;</span><br><span class="line">	Equal(T) <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，Index会把T传给Equaler。其规则就是如果类型约束只有一个类型参数，并且<br>在没有显式的类型实参时将它用在函数的类型参数列表中，那么类型实参就是那个被约束的类型<br>参数。换句话说，<code>Index</code>的定义里约束<code>Equaler</code>其实是<code>Equaler(T)</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// equalInt is a version of int that implements Equaler.</span></span><br><span class="line"><span class="keyword">type</span> equalInt <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The Equal method lets equalInt implement the Equaler constraint.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a equalInt)</span> <span class="title">Equal</span><span class="params">(b equalInt)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> a == b &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// indexEqualInts returns the index of e in s, or -1 if not found.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">indexEqualInt</span><span class="params">(s []equalInt, e equalInt)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> Index(equalInt)(s, e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="相互引用的类型参数"><a href="#相互引用的类型参数" class="headerlink" title="相互引用的类型参数"></a>相互引用的类型参数</h1><p><em>Mutually referencing type parameters</em></p>
<p>类型参数的作用范围从type关键字开始到闭包结束或者类型定义结束。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> graph</span><br><span class="line"></span><br><span class="line"><span class="comment">// NodeConstraint is the type constraint for graph nodes:</span></span><br><span class="line"><span class="comment">// they must have an Edges method that returns the Edge's</span></span><br><span class="line"><span class="comment">// that connect to this Node.</span></span><br><span class="line"><span class="keyword">type</span> NodeConstraint(<span class="keyword">type</span> Edge) <span class="keyword">interface</span> &#123;</span><br><span class="line">	Edges() []Edge</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// EdgeConstraint is the type constraint for graph edges:</span></span><br><span class="line"><span class="comment">// they must have a Nodes method that returns the two Nodes</span></span><br><span class="line"><span class="comment">// that this edge connects.</span></span><br><span class="line"><span class="keyword">type</span> EdgeConstraint(<span class="keyword">type</span> Node) <span class="keyword">interface</span> &#123;</span><br><span class="line">	Nodes() (from, to Node)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Graph is a graph composed of nodes and edges.</span></span><br><span class="line"><span class="keyword">type</span> Graph(<span class="keyword">type</span> Node NodeConstraint(Edge), Edge EdgeConstraint(Node)) <span class="keyword">struct</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New returns a new graph given a list of nodes.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">type</span> Node NodeConstraint(Edge)</span>, <span class="title">Edge</span> <span class="title">EdgeConstraint</span><span class="params">(Node)</span>) <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	nodes []Node)</span> *<span class="title">Graph</span><span class="params">(Node, Edge)</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ShortestPath returns the shortest path between two nodes,</span></span><br><span class="line"><span class="comment">// as a list of edges.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Graph(Node, Edge)</span>) <span class="title">ShortestPath</span><span class="params">(from, to Node)</span> []<span class="title">Edge</span></span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>而在下面的例子里，<code>*Vertex</code>和<code>*FromTo</code>并非接口类型，但它们实现了graph.Graph<br>的约束中的方法?。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vertex is a node in a graph.</span></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Edges returns the edges connected to v.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Edges</span><span class="params">()</span> []*<span class="title">FromTo</span></span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FromTo is an edge in a graph.</span></span><br><span class="line"><span class="keyword">type</span> FromTo <span class="keyword">struct</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Nodes returns the nodes that ft connects.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ft *FromTo)</span> <span class="title">Nodes</span><span class="params">()</span> <span class="params">(*Vertex, *Vertex)</span></span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = graph.New(*Vertex, *FromTo)([]*Vertex&#123; ... &#125;)</span><br></pre></td></tr></table></figure>


<h1 id="指针方法"><a href="#指针方法" class="headerlink" title="指针方法"></a>指针方法</h1><p><em>Pointer methods</em></p>
<p>有时候我们会遇到泛型函数的类型实参A有着接受者为<em>A的方法。<br>下面两种写法都是有问题的。第一种是因为</em>Settable才有Set方法，第二种是因为FromString<br>函数中创建T切片相当于<code>make([]*Settable,...)</code>，此时切片初始元素均为nil因此后面调用<br>方法会出错。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Setter is a type constraint that requires that the type</span></span><br><span class="line"><span class="comment">// implement a Set method that sets the value from a string.</span></span><br><span class="line"><span class="keyword">type</span> Setter <span class="keyword">interface</span> &#123;</span><br><span class="line">	Set(<span class="keyword">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FromStrings takes a slice of strings and returns a slice of T,</span></span><br><span class="line"><span class="comment">// calling the Set method to set each returned value.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Note that because T is only used for a result parameter,</span></span><br><span class="line"><span class="comment">// type inference does not work when calling this function.</span></span><br><span class="line"><span class="comment">// The type argument must be passed explicitly at the call site.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This example compiles but is unlikely to work as desired.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FromStrings</span><span class="params">(<span class="keyword">type</span> T Setter)</span><span class="params">(s []<span class="keyword">string</span>)</span> []<span class="title">T</span></span> &#123;</span><br><span class="line">	result := <span class="built_in">make</span>([]T, <span class="built_in">len</span>(s))</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">		result[i].Set(v)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Settable is a integer type that can be set from a string.</span></span><br><span class="line"><span class="keyword">type</span> Settable <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Set sets the value of *p from a string.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Settable)</span> <span class="title">Set</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	i, _ := strconv.Atoi(s) <span class="comment">// real code should not ignore the error</span></span><br><span class="line">	*p = Settable(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// INVALID</span></span><br><span class="line">	nums1 := FromStrings(Settable)([]<span class="keyword">string</span>&#123;<span class="string">"1"</span>, <span class="string">"2"</span>&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Compiles but does not work as desired.</span></span><br><span class="line">	<span class="comment">// This will panic at run time when calling the Set method.</span></span><br><span class="line">	nums2 := FromStrings(*Settable)([]<span class="keyword">string</span>&#123;<span class="string">"1"</span>, <span class="string">"2"</span>&#125;)</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有一种写法如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> from</span><br><span class="line"></span><br><span class="line"><span class="comment">// Setter2 is a type constraint that requires that the type</span></span><br><span class="line"><span class="comment">// implement a Set method that sets the value from a string,</span></span><br><span class="line"><span class="comment">// and also requires that the type be a pointer to its type parameter.</span></span><br><span class="line"><span class="keyword">type</span> Setter2(<span class="keyword">type</span> B) <span class="keyword">interface</span> &#123;</span><br><span class="line">	Set(<span class="keyword">string</span>)</span><br><span class="line">	<span class="keyword">type</span> *B</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FromStrings2 takes a slice of strings and returns a slice of T,</span></span><br><span class="line"><span class="comment">// calling the Set method to set each returned value.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// We use two different type parameters so that we can return</span></span><br><span class="line"><span class="comment">// a slice of type T but call methods on *T.</span></span><br><span class="line"><span class="comment">// The Setter2 constraint ensures that PT is a pointer to T.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FromStrings2</span><span class="params">(<span class="keyword">type</span> T <span class="keyword">interface</span>&#123;&#125;, PT Setter2(T)</span>)<span class="params">(s []<span class="keyword">string</span>)</span> []<span class="title">T</span></span> &#123;</span><br><span class="line">	result := <span class="built_in">make</span>([]T, <span class="built_in">len</span>(s))</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">		<span class="comment">// The type of &amp;result[i] is *T which is in the type list</span></span><br><span class="line">		<span class="comment">// of Setter2, so we can convert it to PT.</span></span><br><span class="line">		p := PT(&amp;result[i])</span><br><span class="line">		<span class="comment">// PT has a Set method.</span></span><br><span class="line">		p.Set(v)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F2</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// FromStrings2 takes two type parameters.</span></span><br><span class="line">	<span class="comment">// The second parameter must be a pointer to the first.</span></span><br><span class="line">	<span class="comment">// Settable is as above.</span></span><br><span class="line">	nums := FromStrings2(Settable, *Settable)([]<span class="keyword">string</span>&#123;<span class="string">"1"</span>, <span class="string">"2"</span>&#125;)</span><br><span class="line">	<span class="comment">// Now nums is []Settable&#123;1, 2&#125;.</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但上面的Setter2定义有点怪异，将方法和类型约束糅杂在一起并且要传入两个类型参数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FromStrings3 takes a slice of strings and returns a slice of T,</span></span><br><span class="line"><span class="comment">// calling the set function to set each returned value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FromStrings3</span><span class="params">(<span class="keyword">type</span> T)</span><span class="params">(s []<span class="keyword">string</span>, set <span class="keyword">func</span>(*T, <span class="keyword">string</span>)</span>) []<span class="title">T</span></span> &#123;</span><br><span class="line">	results := <span class="built_in">make</span>([]T, <span class="built_in">len</span>(s))</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">		set(&amp;results[i], v)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F3</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// FromStrings3 takes a function to set the value.</span></span><br><span class="line">	<span class="comment">// Settable is as above.</span></span><br><span class="line">	nums := FromStrings3(Settable)([]<span class="keyword">string</span>&#123;<span class="string">"1"</span>, <span class="string">"2"</span>&#125;,</span><br><span class="line">		<span class="function"><span class="keyword">func</span><span class="params">(p *Settable, s <span class="keyword">string</span>)</span></span> &#123; p.Set(s) &#125;)</span><br><span class="line">	<span class="comment">// Now nums is []Settable&#123;1, 2&#125;.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一种写法如上，就是把set方法作为参数传进去，当然还是比较不优雅。</p>
<p>而下面这种就是新草案引入的<code>type *T Setter</code>约束，这意味着两件事，一是<em>T满足Setter约束，<br>而传进去的类型参数不能为指针，不然</em>T为指针则T是指向指针的指针，不可能实现任何方法。</p>
<p>二是函数体内任何调用约束的函数都视为指针方法，只能为*T类型的值调用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FromStrings takes a slice of strings and returns a slice of T,</span></span><br><span class="line"><span class="comment">// calling the Set method to set each returned value.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// We write *T, meaning that given a type argument A,</span></span><br><span class="line"><span class="comment">// the pointer type *A must implement Setter.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Note that because T is only used for a result parameter,</span></span><br><span class="line"><span class="comment">// type inference does not work when calling this function.</span></span><br><span class="line"><span class="comment">// The type argument must be passed explicitly at the call site.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FromStrings</span><span class="params">(<span class="keyword">type</span> *T Setter)</span><span class="params">(s []<span class="keyword">string</span>)</span> []<span class="title">T</span></span> &#123;</span><br><span class="line">	result := <span class="built_in">make</span>([]T, <span class="built_in">len</span>(s))</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">		<span class="comment">// result[i] is an addressable value of type T,</span></span><br><span class="line">		<span class="comment">// so it's OK to call Set.</span></span><br><span class="line">		result[i].Set(v)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// With the rewritten FromStrings, this is now OK.</span></span><br><span class="line">	<span class="comment">// *Settable implements Setter.</span></span><br><span class="line">	nums := from.Strings(Settable)([]<span class="keyword">string</span>&#123;<span class="string">"1"</span>, <span class="string">"2"</span>&#125;)</span><br><span class="line">	<span class="comment">// Here nums is []Settable&#123;1, 2&#125;.</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有一点需要明确，使用<code>type *T Setter</code>不意味着Set方法必须是指针方法，因为值方法也在指针对象<br>的方法集内。</p>
<h1 id="泛型类型用作为匿名函数参数类型"><a href="#泛型类型用作为匿名函数参数类型" class="headerlink" title="泛型类型用作为匿名函数参数类型"></a>泛型类型用作为匿名函数参数类型</h1><p><em>Using generic types as unnamed function parameter types</em></p>
<p>解析<code>var f func(x(T))</code>时有一点会有歧义，就是我们不知道是函数有一个匿名参数类型为x(T)，还<br>是类型为T的参数x。</p>
<p>但后者并不是常见的写法，通常会被gofmt格式化为<code>func(x T)</code>，因此上述写法默认的意思是前者。</p>
<h1 id="类型参数的值并未被装箱"><a href="#类型参数的值并未被装箱" class="headerlink" title="类型参数的值并未被装箱"></a>类型参数的值并未被装箱</h1><p><em>Values of type parameters are not boxed</em></p>
<p>当前Go的实现里，接口类型的值内部都有一个指针。把一个非指针的值放到接口里会使得这个值被<br>装箱。这就意味着事实上的值存在栈或堆的某处，而接口值里持有者指向这个地方的指针。</p>
<p>而在这个设计里，泛型类型的值并未被装箱。比如之前<code>from.Strings</code>的例子里，当类型Settable<br>实例化时会返回类型<code>[]Settable</code>。比如下面的nums虽然是<code>[]Settable</code>类型，但元素可以直接<br>转化为int，表明并没有被装箱。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Settable is an integer type that can be set from a string.</span></span><br><span class="line"><span class="keyword">type</span> Settable <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Set sets the value of *p from a string.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Settable)</span> <span class="title">Set</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// same as above</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// The type of nums is []Settable.</span></span><br><span class="line">	nums, err := from.Strings(Settable)([]<span class="keyword">string</span>&#123;<span class="string">"1"</span>, <span class="string">"2"</span>&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123; ... &#125;</span><br><span class="line">	<span class="comment">// Settable can be converted directly to int.</span></span><br><span class="line">	<span class="comment">// This will set first to 1.</span></span><br><span class="line">	first := <span class="keyword">int</span>(nums[<span class="number">0</span>])</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="More-on-type-lists"><a href="#More-on-type-lists" class="headerlink" title="More on type lists"></a>More on type lists</h1><h1 id="约束中包含类型列表和方法"><a href="#约束中包含类型列表和方法" class="headerlink" title="约束中包含类型列表和方法"></a>约束中包含类型列表和方法</h1><p><em>Both type lists and methods in constraints</em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StringableSignedInteger is a type constraint that matches any</span></span><br><span class="line"><span class="comment">// type that is both 1) defined as a signed integer type;</span></span><br><span class="line"><span class="comment">// 2) has a String method.</span></span><br><span class="line"><span class="keyword">type</span> StringableSignedInteger <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="keyword">type</span> <span class="keyword">int</span>, <span class="keyword">int8</span>, <span class="keyword">int16</span>, <span class="keyword">int32</span>, <span class="keyword">int64</span></span><br><span class="line">	String() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//满足该约束的一个实参类型为MyInt，定义如下：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MyInt is a stringable int.</span></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The String method returns a string representation of mi.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mi MyInt)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">"MyInt(%d)"</span>, mi)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="约束中包含复合类型"><a href="#约束中包含复合类型" class="headerlink" title="约束中包含复合类型"></a>约束中包含复合类型</h1><p><em>Composite types in constraints</em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> byteseq <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="keyword">type</span> <span class="keyword">string</span>, []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其约束意思就是：类型实参必须为string或[]byte，或者某个它们的衍生类型。</p>
<h1 id="类型列表中的类型参数"><a href="#类型列表中的类型参数" class="headerlink" title="类型列表中的类型参数"></a>类型列表中的类型参数</h1><p><em>Type parameters in type lists</em></p>
<p>约束中的类型列表可以利用传入的类型参数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SliceConstraint is a type constraint that matches a slice of</span></span><br><span class="line"><span class="comment">// the type parameter.</span></span><br><span class="line"><span class="keyword">type</span> SliceConstraint(<span class="keyword">type</span> T) <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="keyword">type</span> []T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Map takes a slice of some element type and a transformation function,</span></span><br><span class="line"><span class="comment">// and returns a slice of the function applied to each element.</span></span><br><span class="line"><span class="comment">// Map returns a slice that is the same type as its slice argument,</span></span><br><span class="line"><span class="comment">// even if that is a defined type.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Map</span><span class="params">(<span class="keyword">type</span> S SliceConstraint(E)</span>, <span class="title">E</span> <span class="title">interface</span></span>&#123;&#125;)(s S, f <span class="function"><span class="keyword">func</span><span class="params">(E)</span> <span class="title">E</span>) <span class="title">S</span></span> &#123;</span><br><span class="line">	r := <span class="built_in">make</span>(S, <span class="built_in">len</span>(s))</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">		r[i] = f(v)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MySlice is a simple defined type.</span></span><br><span class="line"><span class="keyword">type</span> MySlice []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DoubleMySlice takes a value of type MySlice and returns a new</span></span><br><span class="line"><span class="comment">// MySlice value with each element doubled in value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoubleMySlice</span><span class="params">(s MySlice)</span> <span class="title">MySlice</span></span> &#123;</span><br><span class="line">	v := Map(MySlice, <span class="keyword">int</span>)(s, <span class="function"><span class="keyword">func</span><span class="params">(e <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> <span class="number">2</span> * e &#125;)</span><br><span class="line">	<span class="comment">// Here v has type MySlice, not type []int.</span></span><br><span class="line">	<span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><p><em>Type conversions</em></p>
<p>类型参数之间可以作为强转的对象。比如下面的Convert函数是ok的，因为Go保证了integer约束里<br>的所有整数都是可以互转的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> integer <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="keyword">type</span> <span class="keyword">int</span>, <span class="keyword">int8</span>, <span class="keyword">int16</span>, <span class="keyword">int32</span>, <span class="keyword">int64</span>,</span><br><span class="line">		<span class="keyword">uint</span>, <span class="keyword">uint8</span>, <span class="keyword">uint16</span>, <span class="keyword">uint32</span>, <span class="keyword">uint64</span>, <span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Convert</span><span class="params">(<span class="keyword">type</span> To, From integer)</span><span class="params">(from From)</span> <span class="title">To</span></span> &#123;</span><br><span class="line">	to := To(from)</span><br><span class="line">	<span class="keyword">if</span> From(to) != from &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"conversion out of range"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> to</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="无类型常量"><a href="#无类型常量" class="headerlink" title="无类型常量"></a>无类型常量</h1><p><em>Untyped constants</em></p>
<p>一些函数会使用无类型常量。只有这个常量能与约束中的所有类型合法作用时这个函数才是合法的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> integer <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="keyword">type</span> <span class="keyword">int</span>, <span class="keyword">int8</span>, <span class="keyword">int16</span>, <span class="keyword">int32</span>, <span class="keyword">int64</span>,</span><br><span class="line">		<span class="keyword">uint</span>, <span class="keyword">uint8</span>, <span class="keyword">uint16</span>, <span class="keyword">uint32</span>, <span class="keyword">uint64</span>, <span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add10</span><span class="params">(<span class="keyword">type</span> T integer)</span><span class="params">(s []T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">		s[i] = v + <span class="number">10</span> <span class="comment">// OK: 10 can convert to any integer type</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This function is INVALID.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add1024</span><span class="params">(<span class="keyword">type</span> T integer)</span><span class="params">(s []T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">		s[i] = v + <span class="number">1024</span> <span class="comment">// INVALID: 1024 not permitted by int8/uint8</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="类型列表中的复合类型的一些说明"><a href="#类型列表中的复合类型的一些说明" class="headerlink" title="类型列表中的复合类型的一些说明"></a>类型列表中的复合类型的一些说明</h1><p><em>Notes on composite types in type lists</em></p>
<p>有时候复合类型嵌入的情况会比较复杂，像下面这种情况v也必须有约束，也就是有隐式的<br><code>interface {type int, float64, uint64}</code>约束。</p>
<p>目前而言并未完全支持该情况。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> structField <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="keyword">type</span> <span class="keyword">struct</span> &#123; a <span class="keyword">int</span>; x <span class="keyword">int</span> &#125;,</span><br><span class="line">		<span class="keyword">struct</span> &#123; b <span class="keyword">int</span>; x <span class="keyword">float64</span> &#125;,</span><br><span class="line">		<span class="keyword">struct</span> &#123; c <span class="keyword">int</span>; x <span class="keyword">uint64</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IncrementX</span><span class="params">(<span class="keyword">type</span> T structField)</span><span class="params">(p *T)</span></span> &#123;</span><br><span class="line">	v := p.x</span><br><span class="line">	v++</span><br><span class="line">	p.x = v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="嵌入的约束的类型列表"><a href="#嵌入的约束的类型列表" class="headerlink" title="嵌入的约束的类型列表"></a>嵌入的约束的类型列表</h1><p><em>Type lists in embedded constraints</em></p>
<p>约束中嵌入了其它约束的话，取它们的交集，比如满足下面的AddableByteseq的Addable和<br>ByteSeq的只有string。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Addable is types that support the + operator.</span></span><br><span class="line"><span class="keyword">type</span> Addable <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="keyword">type</span> <span class="keyword">int</span>, <span class="keyword">int8</span>, <span class="keyword">int16</span>, <span class="keyword">int32</span>, <span class="keyword">int64</span>,</span><br><span class="line">		<span class="keyword">uint</span>, <span class="keyword">uint8</span>, <span class="keyword">uint16</span>, <span class="keyword">uint32</span>, <span class="keyword">uint64</span>, <span class="keyword">uintptr</span>,</span><br><span class="line">		<span class="keyword">float32</span>, <span class="keyword">float64</span>, <span class="keyword">complex64</span>, <span class="keyword">complex128</span>,</span><br><span class="line">		<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Byteseq is a byte sequence: either string or []byte.</span></span><br><span class="line"><span class="keyword">type</span> Byteseq <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="keyword">type</span> <span class="keyword">string</span>, []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AddableByteseq is a byte sequence that supports +.</span></span><br><span class="line"><span class="comment">// This is every type is that is both Addable and Byteseq.</span></span><br><span class="line"><span class="comment">// In other words, just the type string.</span></span><br><span class="line"><span class="keyword">type</span> AddableByteseq <span class="keyword">interface</span> &#123;</span><br><span class="line">	Addable</span><br><span class="line">	Byteseq</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p><em>Implementation</em></p>
<p>Russ Cox在<a href="https://research.swtch.com/generic" target="_blank" rel="noopener">文章</a>里表明了泛型实现必须在slow programmers, slow compilers, slow execution times中做出选择。</p>
<p>本文的草案里允许上面三种选择，但会避免第一种而只在后两种之间做出决定。</p>
<p>-To be Continued-</p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2020/07/13/go2-type-parameters/">
    <time datetime="2020-07-13T10:40:43.000Z" class="entry-date">
        2020-07-13
    </time>
</a>
    
    
  <span class="article-delim">&#8226;</span>
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/generics/" rel="tag">generics</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/golang/" rel="tag">golang</a></li></ul>

    </footer>
</article>


    
<nav class="nav-single">
    <h3 class="assistive-text">文章导航</h3>
    
    
        <span class="nav-next"><a href="/2020/05/29/CPU-Cache%E6%80%BB%E7%BB%93/" rel="next">CPU Cache总结 <span class="meta-nav">→</span></a></span>
    
</nav><!-- .nav-single -->







</div></div>
        <div id="secondary" class="widget-area" role="complementary">
  
    <aside id="search" class="widget widget_search"><form role="search" method="get" accept-charset="utf-8" id="searchform" class="searchform" action="//google.com/search">
    <div>
        <input type="text" value="" name="s" id="s" />
        <input type="submit" id="searchsubmit" value="搜索" />
    </div>
</form></aside>
  
    
  
    
  
    
  <aside class="widget">
    <h3 class="widget-title">Recents</h3>
    <div class="widget-content">
      <ul>
        
          <li>
            <a href="/2020/07/13/go2-type-parameters/">go2_type_parameters</a>
          </li>
        
          <li>
            <a href="/2020/05/29/CPU-Cache%E6%80%BB%E7%BB%93/">CPU Cache总结</a>
          </li>
        
          <li>
            <a href="/2020/05/25/slice-or-slice-pointer/">slice_or_slice_pointer</a>
          </li>
        
          <li>
            <a href="/2020/05/08/string-byte-convert/">string_byte_convert</a>
          </li>
        
          <li>
            <a href="/2020/01/18/sync-atomic/">sync/atomic</a>
          </li>
        
      </ul>
    </div>
  </aside>

  
    
  <aside class="widget">
    <h3 class="widget-title">Tags</h3>
    <div class="widget-content">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Computer-Science/" rel="tag">Computer Science</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/assembly/" rel="tag">assembly</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/atomic/" rel="tag">atomic</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bytes/" rel="tag">bytes</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/generics/" rel="tag">generics</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang/" rel="tag">golang</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/slice/" rel="tag">slice</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/stack/" rel="tag">stack</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/string/" rel="tag">string</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </aside>

  
    
  <aside class="widget">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget-content tagcloud">
      <a href="/tags/Computer-Science/" style="font-size: 10px;">Computer Science</a> <a href="/tags/assembly/" style="font-size: 10px;">assembly</a> <a href="/tags/atomic/" style="font-size: 10px;">atomic</a> <a href="/tags/bytes/" style="font-size: 10px;">bytes</a> <a href="/tags/generics/" style="font-size: 10px;">generics</a> <a href="/tags/golang/" style="font-size: 20px;">golang</a> <a href="/tags/slice/" style="font-size: 10px;">slice</a> <a href="/tags/stack/" style="font-size: 10px;">stack</a> <a href="/tags/string/" style="font-size: 10px;">string</a>
    </div>
  </aside>

  
</div>
      </div>
      <footer id="colophon" role="contentinfo">
    <p>&copy; 2020 John Doe
    All rights reserved.</p>
    <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</footer>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/js/share.js'];</script>

<script src="/js/jquery-3.3.1.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


<script src="/js/navigation.js"></script>

<div id="bg"></div>

  </div>
</body>
</html>